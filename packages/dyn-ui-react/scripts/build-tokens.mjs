import { promises as fs } from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const ROOT_DIR = path.resolve(__dirname, '..');
const TOKENS_DIR = path.join(ROOT_DIR, 'src', 'tokens');
const RAW_DIR = path.join(TOKENS_DIR, 'raw');
const GENERATED_TS_PATH = path.join(TOKENS_DIR, 'generated.ts');
const CSS_OUTPUT_PATH = path.join(TOKENS_DIR, 'tokens.css');

const CATEGORY_PREFIX_MAP = {
  color: 'color',
  spacing: 'spacing',
  typography: '',
  motion: ''
};

const CATEGORY_ORDER = ['color', 'spacing', 'typography', 'motion'];

async function loadRawTokens() {
  const entries = await fs.readdir(RAW_DIR, { withFileTypes: true });
  const tokens = {};

  for (const entry of entries) {
    if (!entry.isFile() || !entry.name.endsWith('.json')) continue;
    const fullPath = path.join(RAW_DIR, entry.name);
    const json = JSON.parse(await fs.readFile(fullPath, 'utf8'));
    for (const [category, value] of Object.entries(json)) {
      if (!tokens[category]) tokens[category] = {};
      tokens[category] = deepMerge(tokens[category], value);
    }
  }

  return tokens;
}

function deepMerge(target, source) {
  if (!source || typeof source !== 'object' || Array.isArray(source)) {
    return source;
  }

  const result = { ...target };
  for (const [key, value] of Object.entries(source)) {
    if (value && typeof value === 'object' && !Array.isArray(value) && !(value.alias || value.value)) {
      result[key] = deepMerge(result[key] ?? {}, value);
    } else {
      result[key] = value;
    }
  }
  return result;
}

function normalizeKey(key) {
  return key
    .replace(/([a-z0-9])([A-Z])/g, '$1-$2')
    .replace(/_/g, '-')
    .toLowerCase();
}

function resolveTokens(tokens) {
  const resolving = new Set();

  const resolveNode = (node, pathStack) => {
    if (typeof node === 'string' || typeof node === 'number') {
      return String(node);
    }

    if (!node || typeof node !== 'object') {
      throw new Error(`Invalid token at ${pathStack.join('.')}`);
    }

    if (typeof node.alias === 'string') {
      const aliasPath = node.alias.split('.');
      const aliasKey = aliasPath.join('.');
      if (resolving.has(aliasKey)) {
        throw new Error(`Circular alias detected for ${aliasKey}`);
      }
      resolving.add(aliasKey);
      const resolved = resolveNode(getByPath(tokens, aliasPath), aliasPath);
      resolving.delete(aliasKey);
      return resolved;
    }

    const result = Array.isArray(node) ? [] : {};
    for (const [key, value] of Object.entries(node)) {
      result[key] = resolveNode(value, [...pathStack, key]);
    }
    return result;
  };

  const resolved = {};
  for (const [category, value] of Object.entries(tokens)) {
    resolved[category] = resolveNode(value, [category]);
  }

  return resolved;
}

function getByPath(obj, pathParts) {
  let current = obj;
  for (const part of pathParts) {
    if (current && typeof current === 'object' && part in current) {
      current = current[part];
    } else {
      throw new Error(`Unable to resolve alias path ${pathParts.join('.')}`);
    }
  }
  return current;
}

function flattenTokens(category, value, prefix = []) {
  if (typeof value === 'string') {
    return [createEntry(category, prefix, value)];
  }

  const entries = [];
  for (const [key, child] of Object.entries(value)) {
    entries.push(...flattenTokens(category, child, [...prefix, key]));
  }
  return entries;
}

function createEntry(category, pathParts, value) {
  const normalizedParts = pathParts.map(normalizeKey);
  const prefix = CATEGORY_PREFIX_MAP[category] ?? category;
  const varParts = prefix ? [prefix, ...normalizedParts] : normalizedParts;
  const cssVar = `--dyn-${varParts.filter(Boolean).join('-')}`;
  const tokenPath = [category, ...normalizedParts.filter(Boolean)].join('.');
  return { cssVar, value, tokenPath };
}

function sortEntries(entries) {
  const categoryIndex = new Map(CATEGORY_ORDER.map((name, index) => [name, index]));
  return entries.sort((a, b) => {
    const [catA] = a.tokenPath.split('.');
    const [catB] = b.tokenPath.split('.');
    const catOrder = (categoryIndex.get(catA) ?? CATEGORY_ORDER.length) -
      (categoryIndex.get(catB) ?? CATEGORY_ORDER.length);
    if (catOrder !== 0) return catOrder;
    return a.cssVar.localeCompare(b.cssVar);
  });
}

function createCss(entries) {
  const lines = entries.map((entry) => `  ${entry.cssVar}: ${entry.value};`).join('\n');
  return `:root {\n${lines}\n}\n`;
}

function createTs(tokens, entries) {
  const header = `/**\n * This file is auto-generated by scripts/build-tokens.mjs.\n * Do not edit this file directly.\n */\n`;
  const tokensJson = JSON.stringify(tokens, null, 2);
  const cssVariables = entries.reduce((acc, entry) => {
    acc[entry.cssVar] = entry.value;
    return acc;
  }, {});
  const cssJson = JSON.stringify(cssVariables, null, 2);
  const ts = `${header}export const tokens = ${tokensJson} as const;\n\n` +
    `export type TokenCategories = keyof typeof tokens;\n` +
    `export type TokenGroup<K extends TokenCategories> = typeof tokens[K];\n\n` +
    `export const cssVariables = ${cssJson} as const;\n\n` +
    `export type CssVariableName = keyof typeof cssVariables;\n\n` +
    `export function buildCssCustomProperties(selector = ':root') {\n` +
    `  const declarations = Object.entries(cssVariables)\n` +
    `    .map(([name, value]) => '  ' + name + ': ' + value + ';');\n` +
    `  return selector + ' {\\n' + declarations.join('\\n') + '\\n}';\n` +
    `}\n\n` +
    `export function tokenVar(name) {\n` +
    `  return 'var(' + name + ')';\n` +
    `}\n`;
  return ts;
}

async function main() {
  await fs.mkdir(TOKENS_DIR, { recursive: true });
  const raw = await loadRawTokens();
  const resolved = resolveTokens(raw);

  const entries = [];
  for (const category of CATEGORY_ORDER) {
    if (!resolved[category]) continue;
    entries.push(...flattenTokens(category, resolved[category]));
  }
  for (const [category, value] of Object.entries(resolved)) {
    if (CATEGORY_ORDER.includes(category)) continue;
    entries.push(...flattenTokens(category, value));
  }

  const sortedEntries = sortEntries(entries);
  const css = createCss(sortedEntries);
  const ts = createTs(resolved, sortedEntries);

  await fs.writeFile(CSS_OUTPUT_PATH, css, 'utf8');
  await fs.writeFile(GENERATED_TS_PATH, `${ts}`, 'utf8');
}

main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
